package models

import (
    "encoding/json"
    "io"
    "io/ioutil"
    "gopkg.in/mgo.v2"
    "gopkg.in/mgo.v2/bson"
    "github.com/revel/revel"
    "github.com/ip4368/go-userprofile"
    "github.com/ip4368/go-password"
    "strings"
    "time"
)

const COODRINATORS = 0
const TUTORS = 1
const STUDENTS = 2

type User_db struct {
    Identifier  [2]string      `bson:"identifier"`
    Passwd      string         `bson:"passwd"`
    Salt        string         `bson:"salt"`
    PrevPasswd  []string       `bson:"prevpasswd,omitempty"`
    Suspended   bool           `bson:"suspended"`
    Name        string         `bson:"name"`
    Id          bson.ObjectId  `bson:"_id,omitempty"`
}

type User_t struct {
    Email      string
    Username   string
    Name       string
    UserIdHex  string
}

type UserInCourse_db map[string]int

type UserInCourse_t struct {
    IdHex    string      `json:"uid"`
    Role     int         `json:"role"`
}

type Course_db struct {
    Name        string             `bson:"name"`
    Description string             `bson:"description"`
    Suspended   bool               `bson:"suspended,omitempty"`
    Users       UserInCourse_db    `bson:"users,omitempty"`
    TimeCreated time.Time          `bson:"timeCreated,omitempty"`
    Id          bson.ObjectId      `bson:"_id,omitempty"`
    Accessments []Stage_db         `bson:"accessments,omitempty"`
}

type Stage_db struct {
    Description string      `bson:"description"`
    Tasks       []Task_db   `bson:"tasks,omitempty"`
}

type Task_db struct {
    Description string         `bson:"description"`
    AllowLang   []string       `bson:"allowLang,omitempty"`
    TestCases   []TestCase_db  `bson:"testCases,omitempty"`
}

type TestCase_db struct {
    Stdin       string            `bson:"stdin"`
    Stdout      OutputHandler_db  `bson:"stdout"`
    Stderr      OutputHandler_db  `bson:"stderr"`
}

type OutputHandler_db struct {
    HandlerType string     `bson:"handlerType"`
    DirectComp  string     `bson:"directComp,omitempty"`
}

type AggregateUser_t struct {
    Detail User_db
    Role   int
}

type CourseWithUsers_t struct {
    Name        string
    Description string
    Suspended   bool
    Users       []AggregateUser_t
    TimeCreated time.Time
    Id          bson.ObjectId
}

type Course_t struct {
    Name         string  `json:"name"`
    Description  string  `json:"description"`
}

type Admin_t struct {
    UserId bson.ObjectId `bson:"uid"`
    Id     bson.ObjectId `bson:"_id,omitempty"`
}

type Details_t struct {
    Details []struct {
        UpdateType  string       `json:"t"`
        UpdateValue interface{}  `json:"v"`
    } `json:"d"`
}

type AutoGenerated struct {
    D []struct {
        T string `json:"t"`
        V bool `json:"v"`
    } `json:"d"`
}

func GuardUsers() {
    localDBSession, err := mgo.Dial("mongodb://localhost/colonnade")
    if err != nil {
        // Only warn since we'll retry later for each request
        revel.WARN.Printf("Could not connect to Mongo DB. Error: %s", err)
    } else {
        users := usersCollection(localDBSession)
        index := mgo.Index{
            Key: []string{"identifier"},
            Unique: true,
            DropDups: true,
            Background: true,
            Sparse: true,
        }
        users.EnsureIndex(index)
        localDBSession.Close()
    }
}

func GuardAdmins() {
    localDBSession, err := mgo.Dial("mongodb://localhost/colonnade")
    if err != nil {
        // Only warn since we'll retry later for each request
        revel.WARN.Printf("Could not connect to Mongo DB. Error: %s", err)
    } else {
        users := adminsCollection(localDBSession)
        index := mgo.Index{
            Key: []string{"uid"},
            Unique: true,
            DropDups: true,
            Background: true,
            Sparse: true,
        }
        users.EnsureIndex(index)
        localDBSession.Close()
    }
}

func ParseBody(body io.Reader, r interface{}) {
    var bodyBytes []byte
    if body != nil {
        bodyBytes, _ = ioutil.ReadAll(body)
    }
    json.Unmarshal([]byte(bodyBytes), &r)
}

func usersCollection(s *mgo.Session) *mgo.Collection {
    return s.DB("colonnade").C("users")
}

func coursesCollection(s *mgo.Session) *mgo.Collection {
    return s.DB("colonnade").C("courses")
}

func adminsCollection(s *mgo.Session) *mgo.Collection {
    return s.DB("colonnade").C("admins")
}

func RegisterHandler(s *mgo.Session, email, username, passwd, name string) int {
    // validate all email, username and password
    if !userprofile.ValidateEmail(email) { return 1 }
    if !userprofile.ValidateUsername(username) { return 2 }
    if !password.ValidatePassword(passwd) { return 3 }
    if !userprofile.ValidateName(name) { return 4 }

    hashed, salt, _ := password.HashAutoSalt(passwd)
    doc := User_db{
        Identifier: [2]string{email, username},
        Passwd: hashed,
        Salt: salt,
        PrevPasswd: []string{},
        Suspended: false,
        Name: name,
    }

    err := usersCollection(s).Insert(doc)

    if err != nil { return 5 }
    return 0
    //
}

func LoginHandler(s *mgo.Session, email, passwd string) (int, [2]string, string, string) {
    // validate password and check against database
    if !userprofile.ValidateEmail(email) { return 1, [2]string{"", ""}, "", "" }
    if !password.ValidatePassword(passwd) { return 1, [2]string{"", ""}, "", "" }

    u := new(User_db)

    usersCollection(s).Find(bson.M{
        "identifier": email,
    }).Select(bson.M{
        "prevpasswd": 0,
    }).One(u)

    if strings.Compare(u.Identifier[0], email) != 0 { return 2, [2]string{"", ""}, "", "" }
    if u.Suspended { return 3, [2]string{"", ""}, "", "" }

    hashed, _, _ := password.HashWithSalt(passwd, u.Salt)
    if strings.Compare(u.Passwd, hashed) != 0 { return 4, [2]string{"", ""}, "", "" }
    return 0, u.Identifier, u.Id.Hex(), u.Name
}

func LoginStatus(user User_t) int {
    if(user.Email == "" && 
       user.Username == "" &&
       user.Name == "" &&
       user.UserIdHex == "") { return 1 }
    return 0;
}

func LogoutHandler(user User_t) int {
    return LoginStatus(user)
}

func CoursesForUser(s *mgo.Session, UserIdHex string) (int, []Course_db, []Course_db, []Course_db) {
    isValidId := bson.IsObjectIdHex(UserIdHex)
    if !isValidId { return 2, []Course_db{}, []Course_db{}, []Course_db{} }

    var result []Course_db
    err := coursesCollection(s).Find(bson.M{
        "$and": []bson.M{
            bson.M{"users." + UserIdHex: bson.M{"$exists": true}},
            bson.M{"suspended": bson.M{"$ne": true}},
        },
    }).Select(bson.M{
        "name": 1,
        "description": 1,
        "users." + UserIdHex: 1,
        "_id": 1,
    }).All(&result)
    if err != nil { return 3, []Course_db{}, []Course_db{}, []Course_db{} }

    var groups [3][]Course_db
    for _, value := range result {
        groups[value.Users[UserIdHex]] = append(groups[value.Users[UserIdHex]], Course_db{
                Name: value.Name,
                Description: value.Description,
                Id: value.Id,
            })
    }

    return 0, groups[COODRINATORS], groups[TUTORS], groups[STUDENTS]
}

func CheckAdmin(s *mgo.Session, user User_t) int {
    if LoginStatus(user) != 0 { return 1 }
    isValidId := bson.IsObjectIdHex(user.UserIdHex)
    if !isValidId { return 3 }
    UserId := bson.ObjectIdHex(user.UserIdHex)

    var result Admin_t
    err := adminsCollection(s).Find(bson.M{"uid": UserId}).One(&result)
    if err != nil { return 2 }

    return 0
}

func IsAdmin(user User_t, admin string) int {
    if LoginStatus(user) != 0 { return 1 }
    if admin != "t" {return 2}
    return 0
}

func AdminCourses(s *mgo.Session, user User_t, admin string, page int) (int, []Course_db) {
    if IsAdmin(user, admin) != 0 { return 1, []Course_db{} }

    var result []Course_db
    var limit = 20
    var skip = page * 20
    err := coursesCollection(s).Find(bson.M{}).Select(bson.M{
        "description": 1,
        "name": 1,
        "timeCreated": 1,
        "_id": 1,
    }).Skip(skip).Limit(limit).All(&result)

    if err != nil { return 2, []Course_db{} }
    return 0, result
}

func AdminCourse(s *mgo.Session, user User_t, admin, courseIdHex string) (int, CourseWithUsers_t) {
    // check admin
    if IsAdmin(user, admin) != 0 { return 1, CourseWithUsers_t{} }

    // check validity of courseId
    if !bson.IsObjectIdHex(courseIdHex) { return 2, CourseWithUsers_t{} }
    courseId := bson.ObjectIdHex(courseIdHex)

    // query to database
    var course Course_db
    err := coursesCollection(s).Find(bson.M{
        "_id": courseId,
    }).One(&course)

    var aggregateUsers []AggregateUser_t
    for userId, role := range course.Users{
        var user User_db
        usersCollection(s).Find(bson.M{
            "_id": bson.ObjectIdHex(userId),
        }).Select(bson.M{
            "_id"        : 1,
            "identifier" : 1,
            "name"       : 1,
            "suspended"  : 1,
        }).One(&user)
        aggregateUsers = append(aggregateUsers, AggregateUser_t{
            Detail : user,
            Role   : role,
        })
    }
    var aggregateCourse CourseWithUsers_t
    aggregateCourse.Name        = course.Name
    aggregateCourse.Description = course.Description
    aggregateCourse.Suspended   = course.Suspended
    aggregateCourse.Users       = aggregateUsers
    aggregateCourse.TimeCreated = course.TimeCreated
    aggregateCourse.Id          = course.Id
    if err != nil { return 3, CourseWithUsers_t{} }
    return 0, aggregateCourse
}

func AdminUsers(s *mgo.Session, user User_t, admin string, page int) (int, []User_db) {
    if IsAdmin(user, admin) != 0 { return 1, []User_db{} }

    var result []User_db
    var limit = 20
    var skip = page * 20
    err := usersCollection(s).Find(bson.M{}).Select(bson.M{
        "_id"        : 1,
        "identifier" : 1,
        "name"       : 1,
        "suspended"  : 1,
    }).Skip(skip).Limit(limit).All(&result)

    if err != nil { return 2, []User_db{} }
    return 0, result
}

func AdminUser(s *mgo.Session, user User_t, admin, userIdHex string) (int, User_db) {
    // check admin
    if IsAdmin(user, admin) != 0 { return 1, User_db{} }

    // check validity of courseId
    if !bson.IsObjectIdHex(userIdHex) { return 2, User_db{} }
    userId := bson.ObjectIdHex(userIdHex)

    // query to database
    var user_data User_db
    err := usersCollection(s).Find(bson.M{
        "_id": userId,
    }).Select(bson.M{
        "_id": 1,
        "identifier": 1,
        "suspended": 1,
        "name": 1,
    }).One(&user_data)

    if err != nil { return 3, User_db{} }
    return 0, user_data
}

func AdminNewCourse(s *mgo.Session, user User_t, admin string, course Course_t) (int, string) {
    if IsAdmin(user, admin) != 0 { return 1, "" }

    id := bson.NewObjectId()
    newCourse := Course_db{
        Name        : course.Name,
        Description : course.Description,
        Suspended   : false,
        Users       : UserInCourse_db{},
        TimeCreated : time.Now(),
        Id          : id,
    }

    err := coursesCollection(s).Insert(newCourse)
    if err != nil { return 2, "" }

    return 0, id.Hex()
}

func AddUser2Course(s *mgo.Session, courseId bson.ObjectId, u UserInCourse_db) int {
    fault := false
    for userId, role := range u{
        err := coursesCollection(s).Update(
            bson.M{"_id": courseId},
            bson.M{"$set": bson.M{"users." + userId: role}},
        )
        if err != nil { fault = true }
    }
    if fault { return 1 }
    return 0
}

func AdminAddUser2Course(s *mgo.Session,
        user User_t,
        admin string,
        courseIdHex string,
        c []UserInCourse_t) (int, []int) {
    if IsAdmin(user, admin) != 0 { return 1, []int{} }

    if !bson.IsObjectIdHex(courseIdHex) { return 2, []int{} }
    courseId := bson.ObjectIdHex(courseIdHex)

    var successUsers []int
    users := make(UserInCourse_db)
    for _, value := range c {
        if bson.IsObjectIdHex(value.IdHex) && value.Role >= COODRINATORS && value.Role <= STUDENTS {
            successUsers = append(successUsers, 0)
            users[value.IdHex] = value.Role
        }else{
            successUsers = append(successUsers, 1)
        }
    }

    if len(users) == 0 { return 3, []int{} }
    result := AddUser2Course(s, courseId, users)
    if result != 0 { return 4, []int{} }
    return 0, successUsers
}

func RemoveUserFromCourse(s *mgo.Session, courseId bson.ObjectId, u []bson.ObjectId) int {
    err := coursesCollection(s).Update(
        bson.M{"_id": courseId},
        bson.M{"$pull": bson.M{
            "users": bson.M{"uid": bson.M{"$in": u}},
        }},
    )

    if err != nil { return 1 }
    return 0
}

func AdminRemoveUserFromCourse(s *mgo.Session,
        user User_t,
        admin string,
        courseIdHex string,
        UsersIdHex []string) (int, []int) {
    
    if IsAdmin(user, admin) != 0 { return 1, []int{} }
    
    if !bson.IsObjectIdHex(courseIdHex) { return 2, []int{} }
    courseId := bson.ObjectIdHex(courseIdHex)

    var successUsers []int
    var users []bson.ObjectId
    for _, value := range UsersIdHex {
        if bson.IsObjectIdHex(value) {
            successUsers = append(successUsers, 0)
            users = append(users, bson.ObjectIdHex(value))
        }else{
            successUsers = append(successUsers, 1)
        }
    }

    if len(users) == 0 { return 3, []int{} }
    result := RemoveUserFromCourse(s, courseId, users)
    if result != 0 { return 4, []int{} }
    return 0, successUsers
}

func UpdateCourseName(s *mgo.Session, courseId bson.ObjectId, data string) int {
    err := coursesCollection(s).Update(
        bson.M{"_id": courseId},
        bson.M{
            "$set": bson.M{"name": data},
        },
    )
    if err != nil { return 1 }
    return 0
}

func UpdateCourseDescription(s *mgo.Session, courseId bson.ObjectId, data string) int {
    err := coursesCollection(s).Update(
        bson.M{"_id": courseId},
        bson.M{
            "$set": bson.M{"description": data},
        },
    )
    if err != nil { return 1 }
    return 0
}

func UpdateCourseSuspended(s *mgo.Session, courseId bson.ObjectId, data bool) int {
    err := coursesCollection(s).Update(
        bson.M{"_id": courseId},
        bson.M{
            "$set": bson.M{"suspended": data},
        },
    )
    if err != nil { return 1 }
    return 0
}

func AdminUpdateCourse(s *mgo.Session, user User_t, admin, IdHex string, details Details_t) (int, []int) {
    if IsAdmin(user, admin) != 0 { return 1, []int{} }

    if !bson.IsObjectIdHex(IdHex) { return 2, []int{} }
    Id := bson.ObjectIdHex(IdHex)

    var success bool = false
    var indivSucc []int
    for _, value := range details.Details {
        var tempSuccess int
        switch value.UpdateType {
            case "Name":
                tempSuccess = UpdateCourseName(s, Id, value.UpdateValue.(string))
            case "Description":
                tempSuccess = UpdateCourseDescription(s, Id, value.UpdateValue.(string))
            case "Suspended":
                tempSuccess = UpdateCourseSuspended(s, Id, value.UpdateValue.(bool))
        }
        indivSucc = append(indivSucc, tempSuccess)
        if tempSuccess == 0 { success = true }
    }
    if !success { return 3, []int{} }
    return 0, indivSucc
}

func UpdateUserName(s *mgo.Session, userId bson.ObjectId, data string) int {
    err := usersCollection(s).Update(
        bson.M{"_id": userId},
        bson.M{
            "$set": bson.M{"name": data},
        },
    )
    if err != nil { return 1 }
    return 0
}

func UpdateUserSuspended(s *mgo.Session, userId bson.ObjectId, data bool) int {
    err := usersCollection(s).Update(
        bson.M{"_id": userId},
        bson.M{
            "$set": bson.M{"suspended": data},
        },
    )
    if err != nil { return 1 }
    return 0
}

func AdminUpdateUser(s *mgo.Session, user User_t, admin, IdHex string, details Details_t) (int, []int) {
    if IsAdmin(user, admin) != 0 { return 1, []int{} }

    if !bson.IsObjectIdHex(IdHex) { return 2, []int{} }
    Id := bson.ObjectIdHex(IdHex)

    var success bool = false
    var indivSucc []int
    for _, value := range details.Details {
        var tempSuccess int
        switch value.UpdateType {
            case "Name":
                tempSuccess = UpdateUserName(s, Id, value.UpdateValue.(string))
            case "Suspended":
                tempSuccess = UpdateUserSuspended(s, Id, value.UpdateValue.(bool))
        }
        indivSucc = append(indivSucc, tempSuccess)
        if tempSuccess == 0 { success = true }
    }
    if !success { return 3, []int{} }
    return 0, indivSucc
}

func GetUserByIdentifier(s *mgo.Session, identifier string, allowSuspend bool) (int, []User_db) {
    var result []User_db
    var query bson.M
    if allowSuspend {
        query = bson.M{"identifier": bson.M{"$regex": ".*" + identifier + ".*"}}
    }else{
        query = bson.M{
            "$and": []bson.M{
                bson.M{"identifier": bson.M{"$regex": ".*" + identifier + ".*"}},
                bson.M{"suspended": bson.M{"$ne": true}},
                },
            }
    }
    err := usersCollection(s).Find(query).Select(bson.M{
        "name": 1,
        "identifier": 1,
        "_id": 1,
    }).Limit(10).All(&result)

    if err != nil { return 1, []User_db{} }
    return 0, result
}

func AdminGetUserByIdentifier(s *mgo.Session,
        user User_t,
        admin string,
        identifier string,
        allowSuspend bool) (int, []User_db) {
    if IsAdmin(user, admin) != 0 { return 1, []User_db{} }

    status, result := GetUserByIdentifier(s, identifier, allowSuspend)
    if status != 0 { return 2, []User_db{} }
    return 0, result
}
